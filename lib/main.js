/* ==========================================================================
 * Dependencies & variables
 * All the libraries and high level objects we use for this plugin
 * ==========================================================================
 */
// An alias for Components.utils
// https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Chrome_Authority
const {Cu} = require("chrome");
// Low level files chrome utilities
const {TextDecoder, TextEncoder, OS} = Cu.import("resource://gre/modules/osfile.jsm", {});

// SDK utilities
// see. https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/core_promise
const {defer} = require('sdk/core/promise');
var pageMod = require("sdk/page-mod");
var tabs = require('sdk/tabs');
var buttons = require('sdk/ui/button/action');
var self = require("sdk/self");
var data = require("sdk/self").data;
var fileIO = require("sdk/io/file");

// Opengpg drives encryption/decryption and key management
var openpgp = require("openpgp");

// Our own app components
var Config = require("./model/config");
var Addon = require("./model/addon");
var FilepickerController = require("./controller/filepicker");
var GpgkeyController = require("./controller/gpgkey");
var SecretController = require("./controller/secret");
var ClipboardController = require("./controller/clipboard");
var SetupController = require("./controller/setup");
var UserController = require("./controller/user");

// console and debug utilities
if(Config.read('debug') == true) {
	require("sdk/preferences/service").set("extensions.sdk.console.logLevel", 'all');
}

// We use this variables to store the references to the pagemods
// It is usefull for example to re-initialize pagemods after a configuration changes
// for example when you change the list of domains that you are running passbolt on
var pageMods = {};

// Content code callbacks are UUIDs generated by the content code and mapped with an anonymous
// function on the content code side. This UUID is given to the add-on code when the content code
// is triggering a request for a process managed at the addon level such as encrypt or decrypt.
// We cannot give directly the function reference since the add-on and content code can only
// communicate via text.
var callbacks = {};

// Each pagemod triggers a worker that can be used to communicate between the add-on and content code.
// We need to store these workers in a global objects because they need to be able to
// communicate with each other
var workers = {};

/* ==========================================================================
 *  Interface changes
 *  Where we affect the look and feel of the firefox instance
 * ==========================================================================
 */
// Add a passbolt button on browser toolbar
var button = buttons.ActionButton({
	id: "passbolt-link",
	label: "Passbolt",
	icon: {
		"16": "./img/logo/icon-16.png",
		"32": "./img/logo/icon-32.png",
		"64": "./img/logo/icon-64.png"
	},
	onClick: function(state) {
    if (Config.read('baseUrl')) {
      tabs.open(Config.read('baseUrl') + '/debug');
    }
    else {
      tabs.open('http://www.passbolt.com');
    }
	}
});

/* ==========================================================================
 *  Page mods
 *  Run scripts in the context of web pages whose URL matches a given pattern.
 *  see. https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod
 * ==========================================================================
 */
/*
 * This pagemod allow inserting classes to help any page
 * to know about the status of the extension, in a modernizr fashion
 */
pageMods.addonDetection = pageMod.PageMod({
	include: '*',
	contentScriptWhen: 'ready',
	contentStyleFile: [],
	contentScriptFile: [
		data.url("js/lib/jquery-2.1.1.min.js"),
		data.url('js/inc/request.js'),
		data.url("js/addon-detection.js")
	],
	onAttach: listenAddonDetectionEvents
});

/*
 * This pagemod help bootstrap the first step of the setup process from a passbolt server app page
 * The pattern for this url, driving the setup bootstrap, is defined in config.json
 */
pageMods.setupBootstrap = pageMod.PageMod({
	include: new RegExp(Config.read('setupBootstrapRegex') + ".*"),
	contentScriptWhen: 'ready',
	contentStyleFile: [],
	contentScriptFile: [
		data.url("js/lib/jquery-2.1.1.min.js"),
		data.url("js/setup-bootstrap.js")
	],
	contentScriptOptions: {
		config: Config.readAll()
	},
	onAttach: listenSetupBootstrapEvents
});

/*
 * This page mod drives the reset of setup process
 * The reset of the setup process is driven on the add-on side, see in ../data/ setup.html and js/setup.js
 */
pageMods.setup = pageMod.PageMod({
  include: data.url("setup.html"),
  contentScriptWhen: 'end',
  contentScriptFile: [
    data.url("js/lib/jquery-2.1.1.min.js"),
    data.url('js/lib/ejs_production.js'),
    data.url('js/lib/uuid.js'),
    data.url("js/lib/farbtastic.js"),
    data.url('js/template.js'),
    data.url('js/inc/file.js'),
    data.url('js/inc/port.js'),
    data.url('js/inc/request.js'),
    data.url('js/inc/keyring.js'),
    data.url("js/inc/event.js"),
    data.url("js/inc/secret_complexity.js"),
    data.url('js/inc/setup/domain_check.js'),
    data.url('js/inc/setup/define_key.js'),
    data.url('js/inc/setup/import_key.js'),
    data.url('js/inc/setup/secret.js'),
    data.url('js/inc/setup/generate_key.js'),
    data.url('js/inc/setup/backup_key.js'),
    data.url('js/inc/setup/key_info.js'),
    data.url('js/inc/setup/security_token.js'),
    data.url('js/inc/setup/password.js'),
    data.url('js/setup.js')
  ],
  contentScriptOptions: {
    config: Config.readAll()
  },
  onAttach: listenSetupEvents
});

/*
 * This page mod drives a convenience config page for debug
 * This allows to not have to go through the setup process steps
 * and perform changes useful for testing that would otherwise break things
 * Like for example changing the public key only on the client but not the server
 */
pageMods.configDebug = pageMod.PageMod({
  include: data.url("config-debug.html"),
  contentScriptWhen: 'end',
  contentStyleFile: [
    data.url("css/config_debug_ff.css"),
  ],
  contentScriptFile: [
    data.url("js/lib/jquery-2.1.1.min.js"),
    data.url('js/lib/uuid.js'),
    data.url('js/inc/port.js'),
    data.url('js/inc/request.js'),
    data.url('js/inc/keyring.js'),
    data.url('js/inc/file.js'),
    data.url("js/config-debug.js")
  ],
  onAttach: listenConfigDebugEvents
});

/*
 * This pagemod drives the dialog/iframe where the user enters the secret key password,
 * also called master password. It is used when encrypting, decrypting, signing, etc.
 */
pageMods.iframeMasterPwd = pageMod.PageMod({
  include: 'about:blank?passbolt=masterInline*',
  contentStyleFile: [
    data.url("css/main_ff.css")
  ],
  contentScriptFile: [
    data.url("js/lib/jquery-2.1.1.min.js"),
    data.url('js/lib/ejs_production.js'),
    data.url('js/lib/uuid.js'),
    data.url('js/template.js'),
    data.url('js/inc/port.js'),
    data.url('js/inc/request.js'),
    data.url('js/inc/keyring.js'),
    data.url("js/inc/event.js"),
    data.url('js/master.js')
  ],
  contentScriptWhen: 'ready',
  contentScriptOptions: {
    expose_messaging: false,
    addonDataPath: data.url(),
    templatePath: './tpl/keyring/master-password.ejs'
  },
  onAttach: listenMasterEvents
});

/*
 * This pagemod drives the progress bar iframe
 * It is used when the add-on is encrypting something
 */
pageMods.iframeProgress = pageMod.PageMod({
  include: 'about:blank?passbolt=progressInline*',
  contentStyleFile: [
    data.url("css/main_ff.css")
  ],
  contentScriptFile: [
    data.url("js/lib/jquery-2.1.1.min.js"),
    data.url('js/lib/ejs_production.js'),
    data.url('js/lib/uuid.js'),
    data.url('js/template.js'),
    data.url('js/inc/port.js'),
    data.url("js/inc/event.js"),
    data.url('js/progress.js')
  ],
  contentScriptWhen: 'ready',
  contentScriptOptions: {
    expose_messaging: false,
    addonDataPath: data.url(),
    templatePath: './tpl/progress/progress.ejs'
  },
  onAttach: listenProgressEvents
});

/*
 * This pagemod drives the iframe used when the user enter a password to be stored by passbolt
 * It is used when creating/editing a new password
 */
pageMods.iframeDecrypt = pageMod.PageMod({
  include: 'about:blank?passbolt=decryptInline*',
  contentStyleFile: [
    data.url("css/main_ff.css")
  ],
  contentScriptFile: [
    data.url("js/lib/jquery-2.1.1.min.js"),
    data.url('js/lib/ejs_production.js'),
    data.url('js/lib/uuid.js'),
    data.url('js/template.js'),
    data.url('js/inc/port.js'),
    data.url('js/inc/request.js'),
    data.url("js/inc/secret.js"),
    data.url('js/inc/secret_complexity.js'),
    data.url('js/inc/event.js'),
    data.url('js/secret_edit.js')
  ],
  contentScriptWhen: 'ready',
  contentScriptOptions: {
    expose_messaging: false,
    addonDataPath: data.url(),
    templatePath: './tpl/secret/edit.ejs'
  },
  onAttach: listenSecretsEvents
});

/*
 * This pagemod drives the main addon app
 * It is inserted in all the pages of a domain that is trusted.
 * Such trust is defined during the first step of the setup process (or in config-debug)
 */
var initPassboltAppPageMod = function() {
  pageMods.passboltApp = pageMod.PageMod({
    include: Config.read('baseUrl') + "*",
    contentScriptWhen: 'ready',
    contentStyleFile: [
      data.url("css/external.css")
    ],
    contentScriptFile: [
      data.url("js/lib/jquery-2.1.1.min.js"),
      data.url('js/lib/uuid.js'),
      data.url("js/inc/event.js"),
      data.url('js/inc/port.js'),
      data.url('js/inc/request.js'),
      data.url("js/inc/secret.js"),
      data.url("js/inc/clipboard.js"),
      data.url("js/app.js")
    ],
    contentScriptOptions: {
      config: Config.readAll()
    },
    onAttach: listenAppEvents
  });
};
initPassboltAppPageMod(); // init the pageMod when browser is launching

/* ==========================================================================
 *  Master password dialog management
 *  @todo move somewhere else?
 * ==========================================================================
 */
/*
 * This utility function allows to manage several password attempts
 * Currently it is used only when decrypting content but this system
 * can be reusable for other features in the future like authentication
 */
var masterPasswordRequiredFor = function(func, token) {
	var deferred = defer(),
		funcArgs = Array.slice(arguments, 2),
		funcResult = null,
		attempts = 0,

		_loop = function(masterPassword) {
			var masterPassword = typeof masterPassword != 'undefined' ? masterPassword : null;

			// Only up to 3 attempts are authorized
			if (attempts > 2) {
				deferred.reject();
				workers['MasterPassword'].port.emit('passbolt.keyring.master.request.complete', token, 'ERROR', attempts);
				return;
			}

			// Try to launch the function given in parameter with the master password given by the password dialog.
			// The function should throw a REQUEST_MASTER_PASSWORD exception if the given master password is wrong.
			try {
				// Add to the master password to the arguments the function is expected
				var funcArgsWithMp = Array.slice(funcArgs);
				funcArgsWithMp.push(masterPassword);

				// Try to launch the function
				funcResult = func.apply(null, funcArgsWithMp);

				// If everything went fine close the master password popup.
				workers['App'].port.emit('passbolt.keyring.master.request.close', token);
				deferred.resolve(funcResult);
			}
			catch(exception) {

				// If the user already attempt to fill the master password through the given popup.
				if (masterPassword !== null) {
					workers['MasterPassword'].port.emit('passbolt.keyring.master.request.complete', token, 'ERROR', attempts);
				}
				// Launch the master password popup.
				else {
					callbacks[token] = function(token, masterPassword) {
						_loop(masterPassword);
					};
					workers['App'].port.emit('passbolt.keyring.master.request', token);
				}
			}
			attempts++;
		};

	_loop();

	return deferred.promise;
};

/* ==========================================================================
 *  Listener's Includes
 *
 *  Listeners help the addon code interact with content code via content/workers
 *  given by the pagemod. Read more about it here:
 *  https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/content_worker
 *
 *  These section contain listeners includes that is reusable by the listeners
 *  themselves. This allows to factorize some code common to many listeners.
 *  For example multiple listeners will be will interested in sending/receiving
 *  encryption and decryption events.
 * ==========================================================================
 */
/*
 * Generic template events
 * Used when a template is requested by the content code and returned by the addon
 */
var includeTemplateListeners = function (worker) {
  // A template is requested.
  worker.port.on('passbolt.template.get', function (tplPath, token) {
    var tpl = data.load(tplPath);
    worker.port.emit('passbolt.template.send', tpl, token);
  });
};

/*
 * GPG Keyring events
 * Used to handle generate and synchronize key events
 * @TODO refactor with GpgKeyringListeners
 */
var includeGpgkeyListeners = function (worker) {

  // Generate a new key
	// Called by generate_keys.js in the setup process
  worker.port.on("passbolt.gpgkey.generate_key_pair", function(token, keyInfo) {
    // Build userId.
		// @todo move userid build logic ot GpgKeyController
    var userId = keyInfo.name +
      (keyInfo.comment != '' ? " (" + keyInfo.comment + ")" : "") +
      " <" + keyInfo.email + ">";
    var key = GpgkeyController
      .generateKeyPair(worker, userId, keyInfo.masterKey, keyInfo.lgth);
    worker.port.emit(
      "passbolt.gpgkey.generate_key_pair.complete",
      token,
      'SUCCESS',
      key
    );
  });

  // Synchronize the public keys with the server
  worker.port.on("passbolt.gpgkeys.sync", function(token) {
    GpgkeyController.sync(worker)
      .then(function(keysCount) {
        worker.port.emit("passbolt.gpgkeys.sync.complete", token, 'SUCCESS', keysCount);
      });
  });

  // Retrieve the public key information.
  worker.port.on("passbolt.gpgkey.publicKeyInfo", function(token, publicArmoredKey) {
    var info = GpgkeyController.publicKeyInfo(worker, publicArmoredKey);
    worker.port.emit("passbolt.gpgkey.publicKeyInfo.complete", token, 'SUCCESS', info);
  });
};

/*
 * User Listeners
 * Used to handle the events related to the current user
 */
var includeUserListeners = function(worker) {
  // Retrieve the current user
  worker.port.on("passbolt.user.me", function(token) {
    UserController.findCurrentUser()
      .then(
				// success
				function(user) {
					worker.port.emit("passbolt.user.me.complete", token, 'SUCCESS', user)
				},
				// fail
				function(response) {
					worker.port.emit("passbolt.user.me.complete", token, 'ERROR', response)
				}
		);
  });
}

/*
 * Secret Listeners
 * Used for encryption and decryption events
 */
var includeSecretListeners = function (worker) {

  // Listen to secret decrypt request event.
  worker.port.on("passbolt.secret.decrypt", function(token, txt) {
    var decrypted = null;

    // Master pwd is required to decrypt a secret.
    masterPasswordRequiredFor(SecretController.decrypt, token, worker, txt)
      .then(function(decrypted) {
        worker.port.emit('passbolt.secret.decrypt.complete', token, 'SUCCESS', decrypted);
      }, function(){
        worker.port.emit('passbolt.secret.decrypt.complete', token, 'ERROR');
      });
  });

  // Listen to secret encrypt request event.
  worker.port.on("passbolt.secret.encrypt", function(token, unarmored, usersIds) {
    // Ensure the keyring of public keys is in sync.
    GpgkeyController.sync()
      .then(function(keysCount) {
        // The encrypted results.
        var armoreds = {},
          completedGoals = 0;

        // If at least one public key has been updated, notify the application.
        if (keysCount) {
          var keysUpdatedTxt = ' key was updated';
          if (keysCount > 1) {
            keysUpdatedTxt = ' keys were updated';
          }
          var notification = {
            'status': 'success',
            'title': keysCount + keysUpdatedTxt,
            'message': ''
          };
          workers['App'].port.emit('passbolt.event.trigger_to_page', 'passbolt_notify', notification);
        }
				// We encrypt for each users and notify the progress
        for (var i in usersIds) {
          var armored = SecretController.encrypt(worker, unarmored, usersIds[i]);
          armoreds[usersIds[i]] = armored;
          completedGoals ++;
          worker.port.emit('passbolt.secret.encrypt.progress', token, armored, usersIds[i], completedGoals);
        }
        worker.port.emit('passbolt.secret.encrypt.complete', token, 'SUCCESS', armoreds, usersIds);
      });
  });
};

/*
 * Config Listeners
 * @TODO refactor debug see app.js
 */
var includeConfigListeners = function (worker) {
  // Listen to config read events.
  worker.port.on("passbolt.config.read", function(token, name) {
    worker.port.emit("passbolt.config.read.complete", token, 'SUCCESS', Config.read(name));
  });

  // Listen to config read all events, and return several entries of config.
  worker.port.on("passbolt.config.readAll", function(token, names) {
    var conf = {};
    for (i in names) {
      conf[names[i]] = Config.read(names[i]);
    }
    worker.port.emit("passbolt.config.readAll.complete", token, 'SUCCESS', conf);
  });

	// List to application config check
	worker.port.on("passbolt.addon.isConfigured", function(token, names) {
		worker.port.emit("passbolt.addon.isConfigured.complete", token, 'SUCCESS', Addon.isConfigured());
	});

  // If config is in debug mode, we allow to write in the config.
  if (Config.read('debug') == true) {

		// Listen to debug the config
		worker.port.on("passbolt.config.debug", function(token) {
			if (Config.read("debug") == true) {
				tabs.activeTab.url = data.url("config-debug.html");
			}
			worker.port.emit("passbolt.config.debug.complete", token, 'SUCCESS');
		});

		// Listen to config read events.
    worker.port.on("passbolt.config.write", function(token, name, value) {
      var write = Config.write(name, value);
      if (write) {
        worker.port.emit("passbolt.config.write.complete", token, 'SUCCESS');
      }
    });
  }
};

/*
 * Clipboard event
 * @TODO flush clipboard event (on logout for example)
 */
var includeClipboardListeners = function (worker) {
  // Listen to copy to clipboard event.
  worker.port.on("passbolt.clipboard.copy", function(txt) {
    ClipboardController.copy(worker, txt);
  });
};

/*
 * Keyring event
 * @TODO refactor with public and private listeners separate
 */
var includeKeyringListeners = function (worker) {

  // Send the private key information to the content code.
  worker.port.on("passbolt.keyring.privateKeyInfo", function(token) {
    var info = GpgkeyController.privateKeyInfo(worker);
		if (typeof info != 'undefined') {
			worker.port.emit("passbolt.keyring.privateKeyInfo.complete", token, 'SUCCESS', info);
		} else {
			worker.port.emit("passbolt.keyring.privateKeyInfo.complete", token, 'ERROR');
		}
  });

  // Send the private key information to the content code.
  worker.port.on("passbolt.keyring.publicKeyInfo", function(token, publicKeyArmored) {
    var info = GpgkeyController.publicKeyInfo(worker, publicKeyArmored);
		if (typeof info != 'undefined') {
    	worker.port.emit("passbolt.keyring.publicKeyInfo.complete", token, 'SUCCESS', info);
		} else {
			worker.port.emit("passbolt.keyring.privateKeyInfo.complete", token, 'ERROR');
		}
  });

  // Find the public key for a given user.
  worker.port.on("passbolt.keyring.findPublicKey", function(token, userId) {
    var publicKey = GpgkeyController.findPublicKey(worker, userId);
		if (typeof publicKey != 'undefined') {
			worker.port.emit("passbolt.keyring.findPublicKey.complete", token, 'SUCCESS', publicKey);
		} else {
			worker.port.emit("passbolt.keyring.findPublicKey.complete", token, 'ERROR');
		}
  });

  // Extract the public key from a private armored key.
  worker.port.on("passbolt.keyring.extractPublicKey", function(token, privateKeyArmored) {
    var publicKeyArmored = GpgkeyController.extractPublicKey(worker, privateKeyArmored);
		if (typeof publicKeyArmored != 'undefined') {
    	worker.port.emit("passbolt.keyring.extractPublicKey.complete", token, 'SUCCESS', publicKeyArmored);
		} else {
			worker.port.emit("passbolt.keyring.extractPublicKey.complete", token, 'ERROR');
		}
  });

  // Listen to import private key event.
  worker.port.on("passbolt.keyring.private.import", function(token, txt) {
    var result = GpgkeyController.importPrivate(worker, txt);
    if (result !== true) {
      worker.port.emit("passbolt.keyring.private.import.complete", token, 'ERROR', result);
    } else {
      worker.port.emit("passbolt.keyring.private.import.complete", token, 'SUCCESS');
    }
  });

  // Listen to import public key event.
  worker.port.on("passbolt.keyring.public.import", function(token, txt, meta) {
    var result = GpgkeyController.importPublic(worker, txt, meta);
    if (result !== true) {
      worker.port.emit("passbolt.keyring.public.import.complete", token, 'ERROR', result);
    } else {
      worker.port.emit("passbolt.keyring.public.import.complete", token, 'SUCCESS');
    }
  });
};

/*
 * @TODO remove?
 */
var includeContextListeners = function (worker) {
  // Set context variables on the target worker.
  worker.port.on("passbolt.context.dispatch", function(toWorker, name, value) {
    workers[toWorker].port.emit('passbolt.context.set', name, value);
  });
};

/*
 * Event listeners
 * Allow brokering events from one content code to the another since a
 * content code must use the app to communicate with another content code
 */
var includeEventListeners = function (worker) {

  // Dispatch an event to another worker.
  worker.port.on("passbolt.event.dispatch", function(toWorker, eventName) {
    var args = Array.slice(arguments, 1);
    workers[toWorker].port.emit.apply(null, args);
  });

  // Dispatch a request to another worker.
	// @todo callbacks variable scope issue
	var callbacks = {};
  var completedCallback = function(token) {
    // If a callback exists for the given token, execute it.s
    if(callbacks[token]) {
      var request = callbacks[token].request,
        args = Array.slice(arguments);
      // Add the message to the message's arguments.
      args.unshift(request + '.complete');
      // Launch the callback associated to the request.
      callbacks[token].completedCallback.apply(null, args);
      // Remove the listener on the complete event.
      workers[callbacks[token].toWorker].port.removeListener(request + '.complete', callbacks[token].completedCallback);
      // Remove the listener on the progress event.
      workers[callbacks[token].toWorker].port.removeListener(request + '.progress', callbacks[token].progressCallback);
      // Delete the callback in the callback stack.
      delete(callbacks[token]);
    }
  };

  var progressCallback = function(token) {
    // If a callback exists for the given token, execute it
    if(callbacks[token]) {
      var request = callbacks[token].request,
        args = Array.slice(arguments);
      // Add the message to the message's arguments.
      args.unshift(request + '.progress');
      // Launch the callback associated to the request.
      callbacks[token].progressCallback.apply(null, args);
    }
  };

  worker.port.on("passbolt.request.dispatch", function(toWorker, request, token) {
    // @todo For now the common behavior is : if the worker doesn't exist, don't dispatch.
    // No error, no exception.
    if (!workers[toWorker]) {
      return;
    }
    callbacks[token] = {
      request: request,
      toWorker: toWorker,
      completedCallback: function() {
        worker.port.emit.apply(null, Array.slice(arguments));
      },
      progressCallback: function() {
        worker.port.emit.apply(null, Array.slice(arguments));
      }
    };

    // Listen to the complete message on the worker we emit the request.
    workers[toWorker].port.on(request + '.complete', completedCallback);

    // Listen to the progress message on the worker we emit the request.
    workers[toWorker].port.on(request + '.progress', progressCallback);

    // Emit the message on the target worker.
    workers[toWorker].port.emit.apply(null, Array.slice(arguments, 1));
  });
};

/*
 * File Listeners
 * Event related to file like open and save
 */
var includeFileListeners = function (worker) {
  // Listen to request to prompt a file.
  worker.port.on("passbolt.file.prompt", function(token) {
    var path = FilepickerController.openFilePrompt();
    if(fileIO.isFile(path)) {
      var fileContent = fileIO.read(path);
      worker.port.emit("passbolt.file.prompt.complete", token, 'SUCCESS', fileContent);
    }
  });
};

/* ==========================================================================
 *  Listeners
 *
 *  Listeners are included for each pagemode. They make the bridge between
 *  the add-on and content code using workers
 * ==========================================================================
 */
// Listen to addon detection pagemod messages
function listenAddonDetectionEvents(worker) {
	workers['AddonDetection'] = worker;

	includeConfigListeners(worker);
}

// Listen to master pagemod messages
function listenMasterEvents(worker) {
  workers['MasterPassword'] = worker;

  includeTemplateListeners(worker);
  includeEventListeners(worker);
  includeConfigListeners(worker);

  worker.port.on('passbolt.keyring.master.request.submit', function(token, masterPassword) {
    callbacks[token](token, masterPassword);
  });
}

// Listen to application pagemod messages
function listenProgressEvents(worker) {
  workers['Progress'] = worker;

  includeTemplateListeners(worker);
  includeEventListeners(worker);
}

// Listen to application pagemod messages
function listenSecretsEvents(worker) {
  workers['Secret'] = worker;

  includeTemplateListeners(worker);
  includeSecretListeners(worker);
  includeContextListeners(worker);
  includeEventListeners(worker);
  includeConfigListeners(worker);
}

// Listen to application pagemod messages
function listenAppEvents(worker) {
  workers['App'] = worker;

  includeTemplateListeners(worker);
  includeSecretListeners(worker);
  includeClipboardListeners(worker);
  includeContextListeners(worker);
  includeEventListeners(worker);
  includeConfigListeners(worker);

	// @TODO remove?
  worker.port.on('passbolt.iframe.context', function(name, value) {
    workers['Secret'].port.emit('passbolt.iframe.context', name, value);
  });

  // The user wants to save his key.
	worker.port.on("passbolt.settings.backup_key", function(token) {
    let encoder = new TextEncoder();
    let array = encoder.encode(GpgkeyController.privateKeyInfo().key);
    let path = FilepickerController.saveFilePrompt("passbolt.asc");
    let promise = OS.File.writeAtomic(path, array);

    promise.then(function () {
      worker.port.emit("passbolt.settings.backup_key.complete", token, 'SUCCESS');
    }, function () {
      worker.port.emit("passbolt.settings.backup_key.complete", token, 'ERROR');
    });
  });
}

// Listen to setup bootstrap pagemod messages
function listenSetupBootstrapEvents(worker) {
  worker.port.on('passbolt.setup.plugin_check', function(info) {
    var { setInterval, clearInterval } = require("sdk/timers");
    // Once the tab is ready, init the setup with the information already gathered.
    tabs.activeTab.on('ready', function() {
      var interval = setInterval(function() {
        if (workers['Setup']) {
          workers['Setup'].port.emit("passbolt.setup.init", info);
          clearInterval(interval);
        }
      }, 150);
    });
    // Redirect the user to the second step.
    tabs.activeTab.url = data.url("setup.html");
  });
}

// Listen to setup pagemod messages
function listenSetupEvents(worker) {
  workers['Setup'] = worker;
	
  includeTemplateListeners(worker);
  includeClipboardListeners(worker);
  includeContextListeners(worker);
  includeGpgkeyListeners(worker);
  includeEventListeners(worker);
  includeFileListeners(worker);
  includeKeyringListeners(worker);

  // Init / Reset the setup. (delete config, flush keyring, etc..)
  worker.port.on("passbolt.setup.init", function(token) {
    SetupController.reset();
    worker.port.emit("passbolt.setup.init.complete", token, 'SUCCESS');
  });

  // The setup has been completed, save the information
  worker.port.on("passbolt.setup.save", function(token, data) {
    SetupController.save(data)
      .then(function() {
        // Destroy the passbolt application pageMod.
        pageMods.passboltApp.destroy();
        // And restart it to make it able to be initialized regarding the variables we gathered during the setup.
        initPassboltAppPageMod();
        worker.port.emit("passbolt.setup.save.complete", token, 'SUCCESS');
      });
  });

	// @TODO move to keyringListeners
  // The user wants to save his generated key.
  worker.port.on("passbolt.setup.backup_key", function(token, key) {
    let encoder = new TextEncoder();
    let array = encoder.encode(key);
    let path = FilepickerController.saveFilePrompt("passbolt.asc");
    let promise = OS.File.writeAtomic(path, array);

    promise.then(function () {
      worker.port.emit("passbolt.setup.backup_key.complete", token, 'SUCCESS');
    }, function () {
      worker.port.emit("passbolt.setup.backup_key.complete", token, 'ERROR');
    });
  });
}

// Listen to setup pagemod messages
function listenConfigDebugEvents(worker) {
  workers['ConfigDebug'] = worker;

  includeTemplateListeners(worker);
  includeContextListeners(worker);
  includeGpgkeyListeners(worker);
  includeEventListeners(worker);
  includeFileListeners(worker);
  includeKeyringListeners(worker);
  includeConfigListeners(worker);
  includeUserListeners(worker);
}
